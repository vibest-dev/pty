{"version":3,"file":"index.mjs","names":[],"sources":["../src/daemon.ts","../src/frame.ts","../src/pending.ts","../src/client.ts","../src/server.ts"],"sourcesContent":["import { spawn, type ChildProcess } from \"node:child_process\";\nimport fs from \"node:fs\";\nimport path from \"node:path\";\nimport { fileURLToPath } from \"node:url\";\n\nexport const DEFAULT_SOCKET_PATH = \"/tmp/rust-pty.sock\";\nexport const DEFAULT_TOKEN_PATH = \"/tmp/rust-pty.token\";\n\nexport type ResolveBinaryPathOptions = {\n  env?: Record<string, string | undefined>;\n  packageRoot?: string;\n};\n\nexport type EnsureDaemonRunningOptions = {\n  binaryPath?: string;\n  socketPath?: string;\n  tokenPath?: string;\n  timeoutMs?: number;\n  env?: Record<string, string | undefined>;\n};\n\nfunction packageRootFromModule(): string {\n  const here = path.dirname(fileURLToPath(import.meta.url));\n  return path.resolve(here, \"..\");\n}\n\nfunction isExecutableFile(candidate: string): boolean {\n  try {\n    return fs.statSync(candidate).isFile();\n  } catch {\n    return false;\n  }\n}\n\nfunction sleep(ms: number): Promise<void> {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\n\nexport function resolveBinaryPath(options: ResolveBinaryPathOptions = {}): string | null {\n  const env = options.env ?? process.env;\n  const override = env.PTY_DAEMON_PATH;\n  if (override && isExecutableFile(override)) {\n    return override;\n  }\n\n  const root = options.packageRoot ?? packageRootFromModule();\n  const candidate = path.join(root, \"bin\", \"vibest-pty-daemon\");\n  if (isExecutableFile(candidate)) {\n    return candidate;\n  }\n\n  return null;\n}\n\nexport function isDaemonReady(socketPath: string, tokenPath: string): boolean {\n  return fs.existsSync(socketPath) && fs.existsSync(tokenPath);\n}\n\nasync function waitForDaemonReady(\n  child: ChildProcess,\n  socketPath: string,\n  tokenPath: string,\n  timeoutMs: number\n): Promise<void> {\n  const startedAt = Date.now();\n  while (Date.now() - startedAt < timeoutMs) {\n    if (isDaemonReady(socketPath, tokenPath)) {\n      return;\n    }\n\n    if (child.exitCode !== null) {\n      throw new Error(`daemon exited early with code ${child.exitCode}`);\n    }\n\n    await sleep(25);\n  }\n\n  throw new Error(`daemon startup timeout after ${timeoutMs}ms`);\n}\n\nexport async function ensureDaemonRunning(\n  options: EnsureDaemonRunningOptions = {}\n): Promise<ChildProcess | null> {\n  const socketPath = options.socketPath ?? DEFAULT_SOCKET_PATH;\n  const tokenPath = options.tokenPath ?? DEFAULT_TOKEN_PATH;\n\n  if (fs.existsSync(socketPath)) {\n    return null;\n  }\n\n  const env = {\n    ...process.env,\n    ...options.env,\n    RUST_PTY_SOCKET_PATH: socketPath,\n    RUST_PTY_TOKEN_PATH: tokenPath,\n  };\n\n  const binaryPath = options.binaryPath ?? resolveBinaryPath({ env });\n  if (!binaryPath) {\n    throw new Error(\"daemon binary not found (set PTY_DAEMON_PATH or install platform package)\");\n  }\n\n  const child = spawn(binaryPath, [], {\n    env,\n    stdio: \"ignore\",\n    detached: false,\n  });\n\n  await waitForDaemonReady(child, socketPath, tokenPath, options.timeoutMs ?? 5000);\n  return child;\n}\n\nexport async function stopDaemon(child: ChildProcess | null | undefined): Promise<void> {\n  if (!child) {\n    return;\n  }\n\n  if (child.exitCode !== null) {\n    return;\n  }\n\n  await new Promise<void>((resolve) => {\n    let finished = false;\n    const finish = (): void => {\n      if (finished) {\n        return;\n      }\n      finished = true;\n      resolve();\n    };\n\n    const termTimer = setTimeout(() => {\n      if (child.exitCode === null) {\n        child.kill(\"SIGKILL\");\n      }\n\n      const killTimer = setTimeout(() => finish(), 1000);\n      child.once(\"exit\", () => {\n        clearTimeout(killTimer);\n        finish();\n      });\n    }, 2000);\n\n    child.once(\"exit\", () => {\n      clearTimeout(termTimer);\n      finish();\n    });\n\n    child.kill(\"SIGTERM\");\n  });\n}\n","import { decode, encode } from \"@msgpack/msgpack\";\n\nexport const DEFAULT_MAX_FRAME_SIZE = 64 * 1024 * 1024; // 64MB\nexport const DEFAULT_MAX_BUFFER_SIZE = 128 * 1024 * 1024; // 128MB\n\nexport class FrameParserError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = \"FrameParserError\";\n  }\n}\n\nexport function encodeFrame(message: unknown): Uint8Array {\n  const payload = encode(message);\n  const frame = new Uint8Array(4 + payload.length);\n  const view = new DataView(frame.buffer, frame.byteOffset, frame.byteLength);\n  view.setUint32(0, payload.length, false);\n  frame.set(payload, 4);\n  return frame;\n}\n\nexport type FrameParserOptions = {\n  maxFrameSize?: number;\n  maxBufferSize?: number;\n};\n\nexport class FrameParser {\n  private buffer = new Uint8Array(0);\n  private readonly maxFrameSize: number;\n  private readonly maxBufferSize: number;\n\n  constructor(options: FrameParserOptions = {}) {\n    this.maxFrameSize = options.maxFrameSize ?? DEFAULT_MAX_FRAME_SIZE;\n    this.maxBufferSize = options.maxBufferSize ?? DEFAULT_MAX_BUFFER_SIZE;\n  }\n\n  push(chunk: Uint8Array): unknown[] {\n    const next = new Uint8Array(this.buffer.length + chunk.length);\n    next.set(this.buffer);\n    next.set(chunk, this.buffer.length);\n    this.buffer = next;\n\n    if (this.buffer.length > this.maxBufferSize) {\n      throw new FrameParserError(\n        `Buffer size ${this.buffer.length} exceeds max ${this.maxBufferSize}`\n      );\n    }\n\n    const messages: unknown[] = [];\n    while (this.buffer.length >= 4) {\n      const view = new DataView(this.buffer.buffer, this.buffer.byteOffset, this.buffer.byteLength);\n      const len = view.getUint32(0, false);\n\n      if (len === 0) {\n        throw new FrameParserError(\"Invalid frame: length is 0\");\n      }\n\n      if (len > this.maxFrameSize) {\n        throw new FrameParserError(\n          `Frame size ${len} exceeds max ${this.maxFrameSize}`\n        );\n      }\n\n      if (this.buffer.length < len + 4) {\n        break;\n      }\n\n      const payload = this.buffer.slice(4, 4 + len);\n      messages.push(decode(payload));\n      this.buffer = this.buffer.slice(4 + len);\n    }\n\n    return messages;\n  }\n\n  reset(): void {\n    this.buffer = new Uint8Array(0);\n  }\n}\n","export type SeqResponse = {\n  type: \"ok\" | \"error\" | \"handshake\";\n  seq: number;\n};\n\nexport type PendingEntry<TResponse extends SeqResponse> = {\n  resolve: (response: TResponse) => void;\n  reject: (error: Error) => void;\n  timer?: ReturnType<typeof setTimeout>;\n};\n\nexport class PendingRequests<TResponse extends SeqResponse = SeqResponse> {\n  private readonly pending = new Map<number, PendingEntry<TResponse>>();\n\n  register(seq: number, timeoutMs?: number): Promise<TResponse> {\n    return new Promise((resolve, reject) => {\n      const entry: PendingEntry<TResponse> = { resolve, reject };\n\n      if (timeoutMs && timeoutMs > 0) {\n        entry.timer = setTimeout(() => {\n          this.pending.delete(seq);\n          reject(new Error(`Request seq=${seq} timed out after ${timeoutMs}ms`));\n        }, timeoutMs);\n      }\n\n      this.pending.set(seq, entry);\n    });\n  }\n\n  resolve(response: TResponse): void {\n    const entry = this.pending.get(response.seq);\n    if (!entry) {\n      return;\n    }\n\n    this.pending.delete(response.seq);\n    if (entry.timer) clearTimeout(entry.timer);\n    entry.resolve(response);\n  }\n\n  rejectAll(error: Error): void {\n    for (const [seq, entry] of this.pending) {\n      if (entry.timer) clearTimeout(entry.timer);\n      entry.reject(error);\n    }\n    this.pending.clear();\n  }\n\n  get size(): number {\n    return this.pending.size;\n  }\n}\n","import { EventEmitter } from \"node:events\";\nimport { readFile } from \"node:fs/promises\";\nimport net from \"node:net\";\nimport type { ChildProcess } from \"node:child_process\";\nimport {\n  DEFAULT_TOKEN_PATH,\n  ensureDaemonRunning,\n  stopDaemon,\n  type EnsureDaemonRunningOptions,\n} from \"./daemon\";\nimport { FrameParser, FrameParserError, encodeFrame } from \"./frame\";\nimport { PendingRequests } from \"./pending\";\n\n// ---------------------------------------------------------------------------\n// Protocol types (aligned with Rust daemon crates/daemon/src/protocol/message.rs)\n// ---------------------------------------------------------------------------\n\nexport type TerminalModes = {\n  application_cursor: boolean;\n  bracketed_paste: boolean;\n  mouse_tracking: boolean;\n  mouse_sgr: boolean;\n  focus_reporting: boolean;\n  alternate_screen: boolean;\n  cursor_visible: boolean;\n  auto_wrap: boolean;\n};\n\nexport type Snapshot = {\n  content: string;\n  rehydrate: string;\n  cols: number;\n  rows: number;\n  cursor_x: number;\n  cursor_y: number;\n  modes: TerminalModes;\n  cwd?: string;\n};\n\nexport type SessionInfo = {\n  id: number;\n  pid: number;\n  pts: string;\n  is_alive: boolean;\n  created_at: string;\n  last_attached_at: string;\n};\n\nexport type CreateOptions = {\n  cwd?: string;\n  cols?: number;\n  rows?: number;\n  env?: Record<string, string>;\n  shell?: string;\n  initial_commands?: string[];\n};\n\n// ---------------------------------------------------------------------------\n// Request / Response discriminated unions\n// ---------------------------------------------------------------------------\n\nexport type Seq = number;\n\nexport type HandshakeRequest = {\n  type: \"handshake\";\n  token: string;\n  protocol_version: number;\n};\n\nexport type CreateRequest = { type: \"create\" } & CreateOptions;\nexport type ListRequest = { type: \"list\" };\nexport type AttachRequest = { type: \"attach\"; session: number };\nexport type DetachRequest = { type: \"detach\"; session: number };\nexport type KillRequest = { type: \"kill\"; session: number };\nexport type KillAllRequest = { type: \"kill_all\" };\nexport type InputRequest = { type: \"input\"; session: number; data: Uint8Array };\nexport type ResizeRequest = { type: \"resize\"; session: number; cols: number; rows: number };\nexport type SignalRequest = { type: \"signal\"; session: number; signal: string };\nexport type ClearScrollbackRequest = { type: \"clear_scrollback\"; session: number };\nexport type AckRequest = { type: \"ack\"; session: number; count: number };\n\nexport type RequestMessage =\n  | HandshakeRequest\n  | CreateRequest\n  | ListRequest\n  | AttachRequest\n  | DetachRequest\n  | KillRequest\n  | KillAllRequest\n  | InputRequest\n  | ResizeRequest\n  | SignalRequest\n  | ClearScrollbackRequest\n  | AckRequest;\n\ntype RequestNoSeq = RequestMessage;\n\nexport type HandshakeResponse = {\n  type: \"handshake\";\n  seq: Seq;\n  protocol_version: number;\n  daemon_version: string;\n  daemon_pid: number;\n};\n\nexport type DaemonOkResponse = {\n  type: \"ok\";\n  seq: Seq;\n  session?: number;\n  sessions?: SessionInfo[];\n  snapshot?: Snapshot;\n};\n\nexport type DaemonErrorResponse = {\n  type: \"error\";\n  seq: Seq;\n  code: string;\n  message: string;\n};\n\ntype HandshakeWireResponse = Omit<HandshakeResponse, \"seq\"> & {\n  seq?: Seq;\n};\n\nexport type ReplyMessage = HandshakeResponse | DaemonOkResponse | DaemonErrorResponse;\n\nexport type BackpressureLevel = \"green\" | \"yellow\" | \"red\";\n\nexport type OutputEvent = { type: \"output\"; session: number; data: Uint8Array };\nexport type ExitEvent = { type: \"exit\"; session: number; code: number; signal?: number };\nexport type BackpressureWarningEvent = {\n  type: \"backpressure_warning\";\n  session: number;\n  queue_size: number;\n  level: BackpressureLevel;\n};\nexport type EventMessage = OutputEvent | ExitEvent | BackpressureWarningEvent;\n\n// Type-safe event map for the client EventEmitter\nexport interface PtyDaemonClientEvents {\n  output: [OutputEvent];\n  exit: [ExitEvent];\n  backpressure_warning: [BackpressureWarningEvent];\n  error: [Error];\n  close: [];\n}\n\ntype RequestOptions = {\n  timeoutMs?: number;\n};\n\nfunction isRecord(value: unknown): value is Record<string, unknown> {\n  return typeof value === \"object\" && value !== null;\n}\n\nfunction isHandshakeWireResponse(value: unknown): value is HandshakeWireResponse {\n  if (!isRecord(value)) {\n    return false;\n  }\n  return (\n    value.type === \"handshake\" &&\n    typeof value.protocol_version === \"number\" &&\n    typeof value.daemon_version === \"string\" &&\n    typeof value.daemon_pid === \"number\" &&\n    (typeof value.seq === \"number\" || typeof value.seq === \"undefined\")\n  );\n}\n\nfunction isDaemonOkResponse(value: unknown): value is DaemonOkResponse {\n  if (!isRecord(value)) {\n    return false;\n  }\n  return value.type === \"ok\" && typeof value.seq === \"number\";\n}\n\nfunction isDaemonErrorResponse(value: unknown): value is DaemonErrorResponse {\n  if (!isRecord(value)) {\n    return false;\n  }\n  return (\n    value.type === \"error\" &&\n    typeof value.seq === \"number\" &&\n    typeof value.code === \"string\" &&\n    typeof value.message === \"string\"\n  );\n}\n\nfunction isOutputEvent(value: unknown): value is OutputEvent {\n  if (!isRecord(value)) {\n    return false;\n  }\n  return (\n    value.type === \"output\" &&\n    typeof value.session === \"number\" &&\n    value.data instanceof Uint8Array\n  );\n}\n\nfunction isExitEvent(value: unknown): value is ExitEvent {\n  if (!isRecord(value)) {\n    return false;\n  }\n  return (\n    value.type === \"exit\" &&\n    typeof value.session === \"number\" &&\n    typeof value.code === \"number\" &&\n    (typeof value.signal === \"number\" || typeof value.signal === \"undefined\")\n  );\n}\n\nfunction isBackpressureWarningEvent(value: unknown): value is BackpressureWarningEvent {\n  if (!isRecord(value)) {\n    return false;\n  }\n  return (\n    value.type === \"backpressure_warning\" &&\n    typeof value.session === \"number\" &&\n    typeof value.queue_size === \"number\" &&\n    typeof value.level === \"string\" &&\n    [\"green\", \"yellow\", \"red\"].includes(value.level as string)\n  );\n}\n\n// ---------------------------------------------------------------------------\n// Error class\n// ---------------------------------------------------------------------------\n\nexport class DaemonError extends Error {\n  constructor(\n    public readonly code: string,\n    message: string,\n  ) {\n    super(`${code}: ${message}`);\n    this.name = \"DaemonError\";\n  }\n}\n\n// ---------------------------------------------------------------------------\n// Client\n// ---------------------------------------------------------------------------\n\nexport type FlowControlOptions = {\n  /**\n   * Auto-ACK threshold (default: 100).\n   * Client will automatically acknowledge every N processed messages.\n   * Set to 0 to disable auto-ACK.\n   */\n  ackThreshold?: number;\n\n  /**\n   * Manual ACK mode. When true, disables auto-ACK and requires manual ACK calls.\n   * Use this for fine-grained flow control.\n   */\n  manualAck?: boolean;\n};\n\nexport type ClientOptions = {\n  socketPath: string;\n  token?: string;\n  tokenPath?: string;\n  protocolVersion?: number;\n  autoStart?: boolean;\n  requestTimeoutMs?: number;\n  daemon?: Omit<EnsureDaemonRunningOptions, \"socketPath\" | \"tokenPath\">;\n  flowControl?: FlowControlOptions;\n};\n\nexport class PtyDaemonClient extends EventEmitter<PtyDaemonClientEvents> {\n  private socket: net.Socket | null = null;\n  private readonly parser = new FrameParser();\n  private readonly pending = new PendingRequests<ReplyMessage>();\n  private readonly socketPath: string;\n  private token?: string;\n  private readonly tokenPath: string;\n  private readonly protocolVersion: number;\n  private readonly autoStart: boolean;\n  private readonly requestTimeoutMs?: number;\n  private readonly daemonOptions: Omit<EnsureDaemonRunningOptions, \"socketPath\" | \"tokenPath\">;\n  private startedDaemon: ChildProcess | null = null;\n  private pendingHandshakeSeq: Seq | null = null;\n  private handshakeResponse: HandshakeResponse | null = null;\n  private handshakePromise: Promise<HandshakeResponse> | null = null;\n  private seq = 1;\n  private closed = false;\n  private processedCounts: Map<number, number> = new Map();\n  private ackThreshold = 100;\n  private manualAckMode = false;\n\n  constructor(options: ClientOptions) {\n    super();\n    this.socketPath = options.socketPath;\n    this.token = options.token;\n    this.tokenPath = options.tokenPath ?? DEFAULT_TOKEN_PATH;\n    this.protocolVersion = options.protocolVersion ?? 1;\n    this.autoStart = options.autoStart ?? true;\n    this.requestTimeoutMs = options.requestTimeoutMs;\n    this.daemonOptions = options.daemon ?? {};\n\n    // Flow control configuration\n    const flowControl = options.flowControl ?? {};\n    this.ackThreshold = flowControl.ackThreshold ?? 100;\n    this.manualAckMode = flowControl.manualAck ?? false;\n\n    if (this.manualAckMode) {\n      this.ackThreshold = 0; // Disable auto-ACK in manual mode\n    }\n  }\n\n  // ---- Connection lifecycle ------------------------------------------------\n\n  async waitForConnection(): Promise<void> {\n    if (this.autoStart) {\n      this.startedDaemon = await ensureDaemonRunning({\n        ...this.daemonOptions,\n        socketPath: this.socketPath,\n        tokenPath: this.tokenPath,\n      });\n    }\n\n    await new Promise<void>((resolve, reject) => {\n      const socket = net.createConnection(this.socketPath, () => {\n        this.socket = socket;\n        resolve();\n      });\n\n      socket.once(\"error\", (err) => {\n        if (!this.socket) {\n          reject(err);\n        } else {\n          this.handleSocketError(err);\n        }\n      });\n      socket.on(\"data\", (buf) => this.onData(buf));\n      socket.on(\"close\", () => this.handleSocketClose());\n    });\n\n    await this.handshake();\n  }\n\n  close(): void {\n    if (this.closed) return;\n    this.closed = true;\n    this.pendingHandshakeSeq = null;\n    this.handshakeResponse = null;\n    this.handshakePromise = null;\n    this.pending.rejectAll(new Error(\"Client closed\"));\n    this.socket?.end();\n    this.socket = null;\n  }\n\n  async shutdown(): Promise<void> {\n    this.close();\n    await stopDaemon(this.startedDaemon);\n    this.startedDaemon = null;\n  }\n\n  get isConnected(): boolean {\n    return this.socket !== null && !this.closed;\n  }\n\n  get daemonProcess(): ChildProcess | null {\n    return this.startedDaemon;\n  }\n\n  // ---- Typed public API ----------------------------------------------------\n\n  async handshake(options?: RequestOptions): Promise<HandshakeResponse> {\n    if (this.handshakeResponse) {\n      return this.handshakeResponse;\n    }\n    if (this.handshakePromise) {\n      return this.handshakePromise;\n    }\n\n    this.handshakePromise = this.performHandshake(options);\n    try {\n      const reply = await this.handshakePromise;\n      this.handshakeResponse = reply;\n      return reply;\n    } finally {\n      this.handshakePromise = null;\n    }\n  }\n\n  private async performHandshake(options?: RequestOptions): Promise<HandshakeResponse> {\n    const token = this.token ?? (await this.readTokenFromFile());\n    this.token = token;\n    const reply = await this.requestRaw(\n      { type: \"handshake\", token, protocol_version: this.protocolVersion },\n      options,\n    );\n    if (reply.type === \"error\") throw new DaemonError(reply.code, reply.message);\n    if (reply.type !== \"handshake\") throw new Error(`Expected handshake, got ${reply.type}`);\n    return reply;\n  }\n\n  async create(\n    options: CreateOptions,\n    reqOptions?: RequestOptions,\n  ): Promise<{ session: number }> {\n    const ok = this.unwrapOk(await this.requestRaw({ type: \"create\", ...options }, reqOptions));\n    return { session: this.requireSession(ok) };\n  }\n\n  async list(reqOptions?: RequestOptions): Promise<SessionInfo[]> {\n    const ok = this.unwrapOk(await this.requestRaw({ type: \"list\" }, reqOptions));\n    return this.requireSessions(ok);\n  }\n\n  async attach(\n    session: number,\n    reqOptions?: RequestOptions,\n  ): Promise<{ session: number; snapshot: Snapshot }> {\n    const ok = this.unwrapOk(await this.requestRaw({ type: \"attach\", session }, reqOptions));\n    return { session: this.requireSession(ok), snapshot: this.requireSnapshot(ok) };\n  }\n\n  async detach(session: number, reqOptions?: RequestOptions): Promise<void> {\n    this.unwrapOk(await this.requestRaw({ type: \"detach\", session }, reqOptions));\n  }\n\n  async kill(session: number, reqOptions?: RequestOptions): Promise<void> {\n    this.unwrapOk(await this.requestRaw({ type: \"kill\", session }, reqOptions));\n  }\n\n  async killAll(reqOptions?: RequestOptions): Promise<number> {\n    const ok = this.unwrapOk(await this.requestRaw({ type: \"kill_all\" }, reqOptions));\n    return this.requireSession(ok);\n  }\n\n  input(session: number, data: Uint8Array): void {\n    this.notifyRaw({ type: \"input\", session, data });\n  }\n\n  write(session: number, data: Uint8Array): void {\n    this.input(session, data);\n  }\n\n  resize(session: number, cols: number, rows: number): void {\n    this.notifyRaw({ type: \"resize\", session, cols, rows });\n  }\n\n  async signal(\n    session: number,\n    signal: string,\n    reqOptions?: RequestOptions,\n  ): Promise<void> {\n    this.unwrapOk(await this.requestRaw({ type: \"signal\", session, signal }, reqOptions));\n  }\n\n  async clearScrollback(session: number, reqOptions?: RequestOptions): Promise<void> {\n    this.unwrapOk(await this.requestRaw({ type: \"clear_scrollback\", session }, reqOptions));\n  }\n\n  /**\n   * Acknowledge processed messages for flow control\n   * This helps the daemon track backpressure and prevent disconnections\n   */\n  ack(session: number, count: number): void {\n    this.notifyRaw({ type: \"ack\", session, count });\n  }\n\n  /**\n   * Set the threshold for automatic ACKs (default: 100 messages)\n   * Set to 0 to disable automatic ACKs\n   */\n  setAckThreshold(threshold: number): void {\n    if (this.manualAckMode && threshold > 0) {\n      throw new Error(\"Cannot enable auto-ACK in manual ACK mode. Create client with manualAck: false\");\n    }\n    this.ackThreshold = threshold;\n  }\n\n  /**\n   * Enable or disable manual ACK mode\n   */\n  setManualAckMode(enabled: boolean): void {\n    this.manualAckMode = enabled;\n    if (enabled) {\n      this.ackThreshold = 0; // Disable auto-ACK\n    } else if (this.ackThreshold === 0) {\n      this.ackThreshold = 100; // Restore default\n    }\n  }\n\n  /**\n   * Get current flow control configuration\n   */\n  getFlowControlConfig(): { ackThreshold: number; manualAckMode: boolean; pendingCounts: Map<number, number> } {\n    return {\n      ackThreshold: this.ackThreshold,\n      manualAckMode: this.manualAckMode,\n      pendingCounts: new Map(this.processedCounts)\n    };\n  }\n\n  /**\n   * Get pending message count for a specific session\n   */\n  getPendingCount(sessionId: number): number {\n    return this.processedCounts.get(sessionId) ?? 0;\n  }\n\n  // ---- Internal helpers ----------------------------------------------------\n\n  private unwrapOk(reply: ReplyMessage): DaemonOkResponse {\n    if (reply.type === \"error\") throw new DaemonError(reply.code, reply.message);\n    if (reply.type !== \"ok\") throw new Error(`Expected ok, got ${reply.type}`);\n    return reply;\n  }\n\n  private requireSession(ok: DaemonOkResponse): number {\n    if (typeof ok.session !== \"number\") {\n      throw new Error(\"Protocol error: missing ok.session\");\n    }\n    return ok.session;\n  }\n\n  private requireSessions(ok: DaemonOkResponse): SessionInfo[] {\n    if (!Array.isArray(ok.sessions)) {\n      throw new Error(\"Protocol error: missing ok.sessions\");\n    }\n    return ok.sessions;\n  }\n\n  private requireSnapshot(ok: DaemonOkResponse): Snapshot {\n    if (!ok.snapshot) {\n      throw new Error(\"Protocol error: missing ok.snapshot\");\n    }\n    return ok.snapshot;\n  }\n\n  private async requestRaw(request: RequestNoSeq, options?: RequestOptions): Promise<ReplyMessage> {\n    if (!this.socket || this.closed) {\n      throw new Error(\"Socket is not connected\");\n    }\n\n    const seq = this.nextSeq();\n    const timeoutMs = options?.timeoutMs ?? this.requestTimeoutMs;\n\n    if (request.type === \"handshake\") {\n      this.pendingHandshakeSeq = seq;\n    }\n\n    const pendingPromise = this.pending.register(seq, timeoutMs);\n    const payload = { ...request, seq };\n    this.socket.write(Buffer.from(encodeFrame(payload)));\n\n    try {\n      return await pendingPromise;\n    } finally {\n      if (request.type === \"handshake\") {\n        this.pendingHandshakeSeq = null;\n      }\n    }\n  }\n\n  private notifyRaw(request: RequestNoSeq): void {\n    if (!this.socket || this.closed) {\n      throw new Error(\"Socket is not connected\");\n    }\n\n    const seq = this.nextSeq();\n    const payload = { ...request, seq };\n    this.socket.write(Buffer.from(encodeFrame(payload)));\n  }\n\n  private onData(buf: Buffer): void {\n    try {\n      const messages = this.parser.push(new Uint8Array(buf));\n      for (const message of messages) {\n        if (isHandshakeWireResponse(message)) {\n          const seq = typeof message.seq === \"number\" ? message.seq : this.takePendingHandshakeSeq();\n          if (typeof seq !== \"number\") {\n            this.emit(\"error\", new Error(\"Protocol error: handshake response missing seq\"));\n            continue;\n          }\n          const reply: HandshakeResponse = { ...message, seq };\n          this.pending.resolve(reply);\n          continue;\n        }\n\n        if (isDaemonOkResponse(message) || isDaemonErrorResponse(message)) {\n          this.pending.resolve(message);\n          continue;\n        }\n\n        if (isOutputEvent(message)) {\n          this.emit(message.type, message);\n          // Auto-ACK if enabled and not in manual mode\n          if (this.ackThreshold > 0 && !this.manualAckMode) {\n            const session = message.session;\n            const count = (this.processedCounts.get(session) ?? 0) + 1;\n            this.processedCounts.set(session, count);\n            if (count >= this.ackThreshold) {\n              this.ack(session, count);\n              this.processedCounts.set(session, 0);\n            }\n          } else if (this.manualAckMode) {\n            // In manual mode, just track the count but don't auto-ACK\n            const session = message.session;\n            const count = (this.processedCounts.get(session) ?? 0) + 1;\n            this.processedCounts.set(session, count);\n          }\n          continue;\n        }\n\n        if (isExitEvent(message)) {\n          this.emit(message.type, message);\n          // Clean up processed counts for this session\n          this.processedCounts.delete(message.session);\n          continue;\n        }\n\n        if (isBackpressureWarningEvent(message)) {\n          this.emit(\"backpressure_warning\", message);\n        }\n      }\n    } catch (err) {\n      const error =\n        err instanceof FrameParserError\n          ? err\n          : err instanceof Error\n            ? err\n            : new Error(String(err));\n      this.emit(\"error\", error);\n      this.close();\n    }\n  }\n\n  private handleSocketError(err: Error): void {\n    this.pendingHandshakeSeq = null;\n    this.handshakeResponse = null;\n    this.handshakePromise = null;\n    this.pending.rejectAll(err);\n    this.parser.reset();\n    this.emit(\"error\", err);\n  }\n\n  private handleSocketClose(): void {\n    this.pendingHandshakeSeq = null;\n    this.handshakeResponse = null;\n    this.handshakePromise = null;\n    if (!this.closed) {\n      this.pending.rejectAll(new Error(\"Socket closed unexpectedly\"));\n    }\n    this.parser.reset();\n    this.socket = null;\n    this.emit(\"close\");\n  }\n\n  private nextSeq(): number {\n    return this.seq++;\n  }\n\n  private takePendingHandshakeSeq(): Seq | undefined {\n    const seq = this.pendingHandshakeSeq ?? undefined;\n    this.pendingHandshakeSeq = null;\n    return seq;\n  }\n\n  private async readTokenFromFile(): Promise<string> {\n    const token = await readFile(this.tokenPath, \"utf8\");\n    return token.trim();\n  }\n}\n\nexport function createClient(options: ClientOptions): PtyDaemonClient {\n  return new PtyDaemonClient(options);\n}\n","import type { ChildProcess } from \"node:child_process\";\nimport { DEFAULT_SOCKET_PATH, DEFAULT_TOKEN_PATH } from \"./daemon\";\nimport { createClient, type ClientOptions, type PtyDaemonClient } from \"./client\";\n\nexport type CreatePtyOptions = Omit<ClientOptions, \"socketPath\" | \"tokenPath\"> & {\n  socketPath?: string;\n  tokenPath?: string;\n};\n\nexport type PtyDaemon = {\n  readonly process: ChildProcess | null;\n  readonly socketPath: string;\n  readonly tokenPath: string;\n  close(): Promise<void>;\n};\n\nexport type PtyInstance = {\n  readonly client: PtyDaemonClient;\n  readonly daemon: PtyDaemon;\n  close(): Promise<void>;\n  shutdown(): Promise<void>;\n};\n\nexport function createPtyClient(options: ClientOptions): PtyDaemonClient {\n  return createClient(options);\n}\n\nexport async function createPty(options: CreatePtyOptions = {}): Promise<PtyInstance> {\n  const socketPath = options.socketPath ?? DEFAULT_SOCKET_PATH;\n  const tokenPath = options.tokenPath ?? DEFAULT_TOKEN_PATH;\n  const clientOptions: ClientOptions = {\n    ...options,\n    socketPath,\n    tokenPath,\n  };\n\n  const client = createPtyClient(clientOptions);\n  await client.waitForConnection();\n\n  const close = async (): Promise<void> => {\n    await client.shutdown();\n  };\n\n  const daemon: PtyDaemon = {\n    get process() {\n      return client.daemonProcess;\n    },\n    socketPath,\n    tokenPath,\n    close,\n  };\n\n  return {\n    client,\n    daemon,\n    close,\n    shutdown: close,\n  };\n}\n"],"mappings":"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"}